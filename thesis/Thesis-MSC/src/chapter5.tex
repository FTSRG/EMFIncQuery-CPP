\chapter{Scaleability and Performance}One of the most important motivating factor for writing a \CPP{} implementationof the local search runtime was performance. The assumption was that the \CPP{}implementation, even though it might have many restrictions, would beconsiderably faster than the original Java one. Several performance benchmarkswere done throughout the development to verify or deny the previous statement.\section{Model}The model used during the performance benchmarks was an instance of thepreviously introduced school metamodel (figure \figref{School_Metamodel}).Table \tabref{model_size} shows the model scales used during performancebenchmarking.\begin{table}[ht]	\footnotesize	\centering	\caption{Model size}\label{tab:model_size}	\begin{tabular}{ | l | c | c | c | c | c | c |}	\hline	Scale	& Model Elements	& References	\\ \hline	1 		&  2\,040			& 12\,633		\\	2 		&  4\,080			& 25\,266		\\	4		&  8\,160			& 50\,532		\\	8		&  16\,320			& 101\,064		\\		16 		&  32\,640			& 202\,128		\\		32		&  65\,280			& 404\,256		\\		64 		&  130\,560			& 808\,512		\\		128 	&  261\,120			& 1\,617\,024	\\		256 	&  522\,240			& 3\,234\,048	\\		512		&  1\,044\,480		& 6\,468\,096	\\	1\,024	&  2\,088\,960		& 12\,936\,192	\\		\hline	\end{tabular}	\label{tab:TabularExample}\end{table}The model size is defined with scale, which is essentially a simple multiplierof the number of instances of each class defined in the metamodel. Largerscales of a model simply created new instances of schools with similarinternal structure, but without any relationships not between the schools. Theinstance model of a specified scale was generated using a deterministicalgorithm which was implemented in the same way in both Java and \CPP{},allowing the comparison of the two framework implementation.The measurements compare the performance of three implementations: Java LocalSearch, Java RETE\cite{EIQ-Rete} and C++ iterator based. The Java Local Searchbased implementation is the Java implementation of the local search algorithmdescribed in this thesis. The search plan generator is the same for boththe Java and \CPP{} Local Search solutions, but the Java implementation hasaccess to the model statistics which can influence the search plans. The JavaRETE algorithm based implementation is the default pattern matchingimplementation used by \EIQ{}, which also means that this is the most mature ofthe three approaches. It allows for incremental pattern matching, whichrequires extensive caching which results in more memory usage and slowerinitial search, but the cache is kept up to date internally throughnotifications from the model, which means the second time a query is run itwill have a constant, very small return time.\section{Performance measurements}The first measurements focus on the time it takes to initialize and execute aquery on a model, retrieving every match. The first pattern is the really simple\emph{students} pattern \listref{meas_students}, which retrieves matches everystudent in the model. The main difficulty for this pattern is that the resultset is very large (more than 2 million elements for the largest scale), thismeans the main bottleneck is the creation of the result set itself.\begin{lstlisting}[frame=single,float=!ht,language=IQPL,label=listing:meas_students, caption=The students pattern]pattern students(student) {	Student(student);}\end{lstlisting}Figure \figref{meas_students} shows the execution times measured for each platformwith different implementations and on three model sizes: 256, 512 and 1024. JavaLS refers to the Java Local Search implementation, while the rest is selfexplanatory.\begin{figure}[!ht]\centering\includegraphics[width=120mm, keepaspectratio]{figures/meas_students.png}\caption{Performance of the \emph{students} query}\label{fig:meas_students}\end{figure}The measured times show the \CPP{} implementation performing considerablybetter, then the Java ones. In the case of such a simple pattern this wasexpected, as the \CPP{} implementation does a lot less preprocessing and most ofthe query time consists of the assembly of the result set. The surprising part isthe fact the Java implementation of the local search algorithm does slightlyworse than the RETE based algorithm, which does a lot of advanced preprocessing andcaching. This could be the result of the immature codebase for the local searchbased implementation, as it is still in development and might have optimizationissues.The next examined pattern is the \emph{classesOfTeacher} pattern(\listref{meas_classesOfTeacher}). This pattern is slightly more complex thanthe previous one, however the result set is really small. The main takeaway fromthis benchmark is how fast an implementation can respond to a very simple querywith only a few thousand matches.\begin{lstlisting}[frame=single,float=!ht,language=IQPL,label=listing:meas_classesOfTeacher, caption=The classesOfTeacher pattern]pattern coursesOfTeacher(course, teacher) {	Teacher.courses(teacher, course);}pattern classesOfTeacher(teacher, schoolClass) {	find coursesOfTeacher(course, teacher);	Course.schoolClass(course, schoolClass);}\end{lstlisting}The following chart (\figref{meas_classesOfTeacher}) shows the results of thisbenchmark. In this case the difference between the Java and \CPP{}implementations is absolutely massive. The most probable reason is thepreprocessing the Java implementations do on the model, which results in theterrible return time. The Java local search implementation lags behind even morethan the last time, again, likely because of the not yet optimized code.\begin{figure}[!ht]\centering\includegraphics[width=120mm,keepaspectratio]{figures/meas_classesOfTeacher.png}\caption{Performance of the \emph{classesOfTeacher} query}\label{fig:meas_classesOfTeacher}\end{figure}The next pattern is the \emph{studentsOfSchool}(\listref{meas_studentOfSchool}), which is a moderately complex pattern. Thecomplexity comes from the fact that it is not possible to navigate through theassociations as described in the pattern because of the direction theassociations can be navigated in, thus the search plan has to overcome this viastarting from the center of the navigation chain and going in both directionsfrom there.\begin{lstlisting}[frame=single,float=!ht,language=IQPL,label=listing:meas_studentOfSchool, caption=The studentOfSchool pattern]pattern studentsOfSchool(student, school) {	Student.schoolClass.courses.school(student, school);}\end{lstlisting}The more advanced pattern means the gap between the \CPP{} and Javaimplementations became slightly smaller as seen on figure\figref{meas_studentOfSchool}. As seen before, the Java local searchimplementation still lags behind the RETE implementation.\begin{figure}[!ht]\centering\includegraphics[width=120mm,keepaspectratio]{figures/meas_studentOfSchool.png}\caption{Performance of the \emph{studentOfSchool} query}\label{fig:meas_studentOfSchool}\end{figure}The next pattern in line is the \emph{mutualFriendsInSchool}. This pattern isthe most complex of all the benchmarked patterns. The pattern searches fortwo students in a single school whose friends with relationship is mutual. Thispattern is an absolute worst case scenario, as it calls an already complexpattern twice resulting in a huge join at as the first steps of the search plan.\begin{lstlisting}[frame=single,float=!ht,language=IQPL,label=listing:meas_mutualFriendsInSchool, caption=The mutualFriendsInSchool pattern]pattern mutualFriendsInOneSchool(studentA, studentB) {	find studentsOfSchool(studentA, school);	find studentsOfSchool(studentB, school);	Student.friendsWith(studentA, studentB);	Student.friendsWith(studentB, studentA);}\end{lstlisting}In the case of this pattern the run times were a lot slower as expected,which is why the times are written in milliseconds instead of microsecondswhile the model scales are much smaller. The results, as seen on figure\figref{meas_mutualFriendsInSchool}, do not continue the trend of the \CPP{}version being faster than the Java implementation. In this case, both \CPP{}implementations are slower then the Java RETE solution, while being slightlyfaster than the Java local search version. The most likely reasons is a suboptimal search plan, which more than likely significantly hurt the performanceof all local search based solutions.\begin{figure}[!ht]\centering\includegraphics[width=120mm,keepaspectratio]{figures/meas_mutualFriendsInSchool.png}\caption{Performance of the \emph{mutualFriendsInSchool} query}\label{fig:meas_mutualFriendsInSchool}\end{figure}The following figure (\figref{meas_second_run}) shows the times measured whenrunning the queries a second time. The pattern used in this benchmark is the\emph{classesOfTeacher} (\listref{meas_classesOfTeacher}). In this case, the\CPP{} implementations performed identical to the first run. The Java localsearch based version shows slight massive improvements in its speed. The reasonfor the speedup is that no preprocessing is necessary this time. The mostsignificant upgrade in speed is in the case of the Java RETE algorithm basedsolution, as the times dropped to constant 1 ms independent from the model size.This is because of the caching and incremental updating this algorithm iscapable of.\begin{figure}[!ht]\centering\includegraphics[width=120mm,keepaspectratio]{figures/meas_second_run.png}\caption{Performance of the second run of a query}\label{fig:meas_second_run}\end{figure}The last figure (\figref{meas_runtime_vs_iterator}) demonstrates theperformance difference between the iterator based solution and the runtime basedone using the \emph{studentsOfSchool} pattern. The two solutions are qute closeto each other, they stay within 5-10\% of each other on most measurements withthe iterator based solution being the faster one. This is most likely becauseit is not necessary to select the next search operation from an array as thesearch operations are hard coded in the code.\begin{figure}[!ht]\centering\includegraphics[width=120mm,keepaspectratio]{figures/meas_runtime_vs_iterator.png}\caption{Performance comparison of the runtime and iterator based implementations}\label{fig:meas_runtime_vs_iterator}\end{figure}