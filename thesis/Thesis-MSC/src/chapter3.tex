\chapter{Overview of Approach}This chapter will mostly focus on the main design decisions and the architectureof the application.%----------------------------------------------------------------------------
\section{Architecture}\label{sec:Architecture}
%----------------------------------------------------------------------------The application's componetns can be separated into three main categories:\begin{itemize}
  \item Java-Compile Time - components that are used while designing the  queries and generating code.  \item \CPP{} Compile Time - the generated code.  \item \CPP{} Runtime - the code running the queries.
\end{itemize}The architecture of the application is shown on figure \figref{architecture}.The main component of the architecture is the abstract model. This modelserves as the description of the possible object types and their relationships.In my case this is basically similar to an UML class diagram. Furtherdetail will be discussed in chapter \sectref{CppObjectModel}.\begin{figure}[!ht]\centering\includegraphics[width=150mm, keepaspectratio]{figures/architecture.png}\caption{The architecture of the engine.}\label{fig:architecture}\end{figure}From the abstract model, the POCO generator (\sectref{GeneratedCodeStructure}) generates the\CPP{} classes. These are the classes the runtime instantiates and the queriescan run on.To write queries, a query editor is supplied with the application. This editorallows writing the queries with content assist and refactoring support. Thepattern language is similar to the EMF-IncQuery pattern language, the maindifference is the model it works on is not an EMF metamodel, but the abstractmodel defined by the user.From the query definition the search graph (called \emph{PSystem} inEMF-IncQuery) gets transformed. This search graph contains every informationnecessary to create the search plan. The search plan gets transformed from thesearch graph in java at first, then based on this plan the actual searchoperations get transformed into \CPP{} code. The available search operations andtheir execution is coded in a runtime library. The assembly of the actual searchplan and it's execution gets obfuscated by some generated code, the useronly has to call the appropriate generated method to get the matching elementsto a specific query.This architecture makes it so that the user only has no interaction with anylocalsearch related part of the application, i.e. he has to create the model,write the queries and later on call the queries in his \CPP{} application,everything else is handled hidden from him.